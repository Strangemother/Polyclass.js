{"version":3,"file":"font-pack.js","sources":["../src/addons/font-pack.js"],"sourcesContent":["/**\r\n * # Font Pack\r\n * Install a \"font-pack-*\" receiver, allowing the automatic collection\r\n * of google fonts.\r\n *\r\n * + detect named fonts\r\n * + Install google font header\r\n * + create font classes\r\n * + Generate the assigned class\r\n *\r\n * The definition for a font mimics the font string for a google-font, for example\r\n *\r\n *      font-pack-roboto-400\r\n *\r\n * It can be extended to include multiple sizes. an `i` prefix denoted italic_:\r\n *\r\n *      font-pack-roboto-100-400-900-i300\r\n *\r\n * Multple fonts can be stacked, spaces in fonts are `+`:\r\n *\r\n *      font-pack-roboto-400-i900-roboto+mono-300-i300-400-i400\r\n *\r\n * The receiver detects the break between `i900-roboto+mono` because `rob...`\r\n * is not a font-weight type.\r\n *\r\n * This _defines_ the font, writing a the availble font styles\r\n * e.g. `font-roboto-400`\r\n *\r\n * the receiver detects the key `font-roboto-*`, others include:\r\n *\r\n * + font-robot-100\r\n * + font-robot-i900\r\n * + font-robot+mono-400\r\n *\r\n * Applied to the chosen node. This can work on the body, provide defaults for\r\n * all nodes:\r\n *\r\n *     <body class=\"font-roboto-400\">\r\n *         <div id=\"demo_space\" class='font-pack-roboto-400-900-i400'>\r\n *         </div>\r\n *     </body>\r\n *\r\n *\r\n */\r\nconst fontPackReceiver = (function(){\r\n\r\n    let cg;\r\n\r\n    /**\r\n     * The _automatic_ function called at the base of this iffe to\r\n     * install the `font-pack-*` tokens into the class graph.\r\n     *\r\n     * @return {undefined}\r\n     */\r\n    const insertReceiver = function(){\r\n        // console.log('font-pack insertReceiver')\r\n\r\n        /**\r\n         * Install the dynamic sheet addon `fontPackReceiver` of which\r\n         * is called when the dcss is prepared.\r\n         * @param  {ClassGraph} _cg An instance of the live class graph\r\n         * @return {undefined}\r\n         */\r\n        DynamicCSSStyleSheet.addons.fontPackReceiver = function(_cg){\r\n            cg = _cg;\r\n            cg.insertReceiver(['font', 'pack'], fontPackReceiver)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The handler function given to the dynamic css stylesheet, called\r\n     * when the dcss is prepared.\r\n     *\r\n     * This function activates upon a `font-pack-*` a tree call, converting\r\n     * the leaf object to a font family string.\r\n     * Once generated a new <link> is applied to the HTML head\r\n     *\r\n     * @param  {object} obj  A definition generated by the class graph discovery\r\n     * @return {undefined}\r\n     */\r\n    const fontPackReceiver =  function(obj) {\r\n\r\n        // Tokenize as a family string.\r\n        //\r\n        values = obj.values\r\n\r\n        let fonts = createFontObjects(values)\r\n        let familyStrings = createFamilyString(values, fonts)\r\n\r\n        // let families = tokenize(values)\r\n\r\n        // install as header <link> items\r\n        // console.info('Installing Google fonts: familyStrings:', familyStrings)\r\n        generateGoogleLinks(familyStrings).forEach((x)=>document.head.appendChild(x))\r\n\r\n\r\n        // Install additional css additions\r\n        installFontObjects(fonts)\r\n    }\r\n\r\n    const installFontObjects = function(fonts) {\r\n        // // For value create a font-family;\r\n        for(let pack of Object.values(fonts)) {\r\n            let name = pack.first\r\n            let replaceFunc = ($, ofs) => (ofs ? ' ' : \"\") //+ $.toLowerCase()\r\n            let cleanName = toTitleCase(name.replace(/[+]/g, replaceFunc))\r\n            console.log('Installing Font', cleanName)//, pack)\r\n            pack.cleanName = cleanName\r\n            pack.definition = makeDefinitions(pack)\r\n            let installed = cg.dcss.addStylesheetRules(pack.definition);\r\n            installed.renderAll()\r\n        }\r\n    }\r\n\r\n\r\n    const toTitleCase = function(str) {\r\n        return str.replace(/(^|\\s)\\S/g, function(t) { return t.toUpperCase() });\r\n    }\r\n\r\n    const createFamilyString = function(values, fonts) {\r\n        fonts = fonts || createFontObjects(values)\r\n        let fs = function(e) {\r\n            return `family=${e.str}`\r\n        }\r\n\r\n        return Object.values(fonts).flatMap((e)=>fs(e)).join('&')\r\n    }\r\n\r\n    const makeDefinitions = function(pack) {\r\n        /*\r\n            .roboto-i400 {\r\n                font-family: Roboto;\r\n                font-weight: 300;\r\n                font-style: italic;\r\n            }\r\n\r\n        pack:\r\n            cleanName:\"Roboto\"\r\n            first:\"roboto\"\r\n            formatStringParts:(2) ['ital', 'wght']\r\n            str:\"Roboto:ital,wght@0,100;0,400;0,900;1,300;1,400;1,700;1,900\"\r\n            titleToken:\"Roboto\"\r\n            tokens:\r\n                100:{int: 100, regu: 1}\r\n                300:{int: 300, ital: 1}\r\n                400:{int: 400, regu: 1, ital: 1}\r\n                700:{int: 700, ital: 1}\r\n                900:{int: 900, regu: 1, ital: 1}\r\n         */\r\n        let res = {}\r\n        for(let token of Object.values(pack.tokens)) {\r\n            // console.log('making on token' , token)\r\n            let def = {\r\n                'font-weight': token.int\r\n                , 'font-family': `'${pack.cleanName}', sans-serif`\r\n            }\r\n            let selectorBits = ['font', pack.first]\r\n\r\n            for(let key of token.keys) {\r\n                let newDef = Object.assign({}, def)\r\n                if(key.isItal) {\r\n                    newDef['font-style'] = 'italic'\r\n                }\r\n\r\n                let selectorRange = selectorBits.concat([key.token])\r\n                let packName = cg.asSelectorString(selectorRange)\r\n                // console.log(packName, newDef)\r\n                res[packName] = newDef\r\n            }\r\n\r\n        }\r\n        return res\r\n    }\r\n\r\n    const createFontObjects = function(values) {\r\n        // family=Roboto:wght@300\r\n        // let familyStrings = '' //\"family=Roboto:wght@300\"\r\n        let index = 0\r\n        let fonts = {}\r\n\r\n        let currentFont;\r\n        let regex = /([a-zA-Z-]{0,}?)(\\d+)/;\r\n        let REGULAR = 'r' // a no definition (standard) font\r\n        let skipEmpty = true\r\n        let manyFont = true\r\n\r\n        for(let t in values) {\r\n\r\n            // A token will be a name or a format type.\r\n            // iterate forward. Test n+1; if n+1 is not a weight, break\r\n            // else continue digesting the weights until a not weight is met.\r\n            // This produces a object dict of { value, font, weights }\r\n            /*\r\n                for token in tokens:\r\n                    if token is not value-like:\r\n                        fonts[token] = current_font = { token, weights:[\r\n\r\n                        ] }\r\n                    else:\r\n                        current_font.weights += token\r\n\r\n             */\r\n            let token = values[t]\r\n\r\n            // if token is weight, stack into the previous (current) font.\r\n            if(index == 0) {\r\n                // the first token should be a font.\r\n                fonts[index] = { first: token, tokens:{} }\r\n                currentFont = index\r\n                index++;\r\n                continue\r\n            }\r\n\r\n            let [prefix, int] = [null, null]\r\n            try{\r\n                // if match int, {v|r|i}int, stack, else continue.\r\n                let _;\r\n                [_, prefix, int] = token.match(regex);\r\n                // console.log(prefix || REGULAR, int)\r\n                if(prefix.length == 0) {\r\n                    prefix = REGULAR\r\n                }\r\n            } catch {\r\n                if(manyFont) {\r\n                    // regenerate the current font and continue forward.\r\n                    // console.log('Building font space', token)\r\n                    fonts[index] = { first: token, tokens:{} }\r\n                    currentFont = index\r\n                    index++;\r\n                    continue\r\n                } else {\r\n\r\n                    // bad token\r\n                    if(token.length == 0\r\n                        && skipEmpty == true) {\r\n                        //skip the empties\r\n                        index++;\r\n                        continue\r\n                    }\r\n                    console.warn(`Bad token: \"${token}\"`)\r\n                }\r\n            }\r\n\r\n            let prefixMap = {\r\n                // Here we flag italic or regular.\r\n                // Google fonts accept a formatter \"ital,wght\" and a value \"0,100\"\r\n                // italic flag 1: \"1,100\"\r\n                null: function(){ /* do nothing */ return { regu: 1, wasNull: 1} }\r\n                , 'i': function(){ /* flag italic */  return { ital: 1 } }\r\n                , 'r': function(){ /* flag regular */ return { regu: 1 } }\r\n            }\r\n\r\n            let weightDef = {\r\n                int: Number(int)\r\n\r\n            }\r\n\r\n            if(weightDef.int == 0) {\r\n                // The given weight is likely wrong.\r\n                console.warn('Skipping zero weighted item')\r\n                index++;\r\n                continue\r\n            }\r\n\r\n            for(let bit in prefix) {\r\n                let v = prefix[bit]\r\n                let actuator = prefixMap[v]\r\n                Object.assign(weightDef, actuator())\r\n            }\r\n\r\n            // console.log('weightDef', weightDef);\r\n\r\n            let existing = fonts[currentFont]?.tokens[int] || {};\r\n\r\n            Object.assign(existing, weightDef)\r\n            // console.log('Adding to existing keys', token)\r\n            if(existing.keys == undefined) {\r\n                existing.keys = new Set\r\n            }\r\n            existing.keys.add({ isItal: weightDef.ital, token})\r\n            fonts[currentFont].tokens[int] = existing;\r\n            index++;\r\n        }\r\n\r\n        return stringifyTokenized(fonts);\r\n    }\r\n\r\n    const stringifyTokenized = function(fonts){\r\n        // now make family strings on each type\r\n        for(let i in fonts) {\r\n            let pack = fonts[i]\r\n\r\n            if(pack.first.length == 0) {\r\n                //skip blank entries\r\n                continue\r\n            }\r\n\r\n            extendPack(pack)\r\n        }\r\n\r\n\r\n        return fonts\r\n    }\r\n\r\n    const extendPack = function(pack) {\r\n        let titleToken = toTitleCase(pack.first);\r\n\r\n        let allTokens = Object.assign({}, ...Object.values(pack.tokens))\r\n        let hasItal = allTokens.ital != undefined\r\n\r\n        let formatStringParts = []\r\n        if(hasItal) { formatStringParts.push('ital') }\r\n        if(hasItal || allTokens.regu) { formatStringParts.push('wght') }\r\n\r\n        let weightValues = new Set\r\n\r\n        for(let key in pack.tokens) {\r\n            let token = pack.tokens[key]\r\n            // console.log(token)\r\n            let ital = token.ital? 1: 0\r\n            let int = token.int\r\n            let a = hasItal? [ital]: []\r\n            a.push(int)\r\n            let weightStr = a.join(',')\r\n            weightValues.add(weightStr)\r\n\r\n            if(token.regu != undefined) {\r\n                let a0 = hasItal? [0]: []\r\n                a0.push(int)\r\n                let regWeightStr = a0.join(',')\r\n                weightValues.add(regWeightStr)\r\n\r\n            }\r\n        }\r\n\r\n        let weights = Array.from(weightValues).sort()//.join(';')\r\n        let totalWeightStr = weights.join(';')\r\n        let formatString = formatStringParts.join(',')\r\n        let str = `${titleToken}:${formatString}@${totalWeightStr}`\r\n\r\n        Object.assign(pack, {\r\n            weights\r\n            , formatStringParts\r\n            , titleToken\r\n            , str\r\n        })\r\n    }\r\n\r\n    const generateGoogleLinks = function(familyStrings){\r\n\r\n        let a = getOrCreateLink('link', 'preconnect', {\r\n            href: \"https://fonts.googleapis.com\"\r\n        })\r\n\r\n        let b = getOrCreateLink('link', 'preconnect', {\r\n            href: \"https://fonts.gstatic.com\"\r\n            , crossorigin: ''\r\n        })\r\n\r\n        let c = getOrCreateLink('link', \"stylesheet\", {\r\n            href:`https://fonts.googleapis.com/css2?${familyStrings}&display=swap`\r\n        })\r\n\r\n        return [a,b,c]\r\n    }\r\n\r\n    let linkCache = {}\r\n\r\n    const getOrCreateLink = function(href, rel, opts) {\r\n        let v = {\r\n            rel, href\r\n        }\r\n        Object.assign(v, opts || {})\r\n        let conv = JSON.stringify\r\n        let cached = linkCache[conv(v)]\r\n        if(cached){\r\n            return cached\r\n        }\r\n\r\n        return linkCache[conv(v)] = createNode('link', v)\r\n    }\r\n\r\n    const createNode = function(name, attrs) {\r\n        if(attrs == undefined && typeof(name) != 'string') {\r\n            attrs = name;\r\n            name = attrs.localName\r\n            if(name == undefined) {\r\n                throw Error('createNode requires a localName within a object definition')\r\n            }\r\n        }\r\n\r\n        let node = document.createElement(name)\r\n        for(let key in attrs) {\r\n            node.setAttribute(key, attrs[key])\r\n        }\r\n        return node\r\n    }\r\n\r\n    ;insertReceiver();\r\n\r\n    return fontPackReceiver\r\n\r\n})()\r\n"],"names":["cg","fontPackReceiver","obj","values","fonts","createFontObjects","familyStrings","createFamilyString","generateGoogleLinks","forEach","x","document","head","appendChild","installFontObjects","pack","Object","name","first","replaceFunc","$","ofs","cleanName","toTitleCase","replace","console","log","definition","makeDefinitions","dcss","addStylesheetRules","renderAll","str","t","toUpperCase","flatMap","e","fs","join","res","token","tokens","def","int","selectorBits","key","keys","newDef","assign","isItal","selectorRange","concat","asSelectorString","currentFont","index","regex","prefix","_","match","length","prefixMap","null","regu","wasNull","i","ital","r","weightDef","Number","warn","bit","actuator","existing","undefined","Set","add","stringifyTokenized","extendPack","titleToken","allTokens","hasItal","formatStringParts","push","weightValues","a","weightStr","a0","regWeightStr","weights","Array","from","sort","totalWeightStr","getOrCreateLink","href","crossorigin","linkCache","rel","opts","v","conv","JSON","stringify","cached","createNode","attrs","localName","Error","node","createElement","setAttribute","DynamicCSSStyleSheet","addons","_cg","insertReceiver"],"mappings":"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"}