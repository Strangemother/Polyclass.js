/**
 * # Font Pack
 * Install a "font-pack-*" receiver, allowing the automatic collection
 * of google fonts.
 *
 * + detect named fonts
 * + Install google font header
 * + create font classes
 * + Generate the assigned class
 *
 * The definition for a font mimics the font string for a google-font, for example
 *
 *      font-pack-roboto-400
 *
 * It can be extended to include multiple sizes. an `i` prefix denoted italic_:
 *
 *      font-pack-roboto-100-400-900-i300
 *
 * Multple fonts can be stacked, spaces in fonts are `+`:
 *
 *      font-pack-roboto-400-i900-roboto+mono-300-i300-400-i400
 *
 * The receiver detects the break between `i900-roboto+mono` because `rob...`
 * is not a font-weight type.
 *
 * This _defines_ the font, writing a the availble font styles
 * e.g. `font-roboto-400`
 *
 * the receiver detects the key `font-roboto-*`, others include:
 *
 * + font-robot-100
 * + font-robot-i900
 * + font-robot+mono-400
 *
 * Applied to the chosen node. This can work on the body, provide defaults for
 * all nodes:
 *
 *     <body class="font-roboto-400">
 *         <div id="demo_space" class='font-pack-roboto-400-900-i400'>
 *         </div>
 *     </body>
 *
 *
 */
;(function(){

    let cg;

    /**
     * The _automatic_ function called at the base of this iffe to
     * install the `font-pack-*` tokens into the class graph.
     *
     * @return {undefined}
     */
    const insertReceiver = function(){
        // console.log('font-pack insertReceiver')

        /**
         * Install the dynamic sheet addon `fontPackReceiver` of which
         * is called when the dcss is prepared.
         * @param  {ClassGraph} _cg An instance of the live class graph
         * @return {undefined}
         */
        DynamicCSSStyleSheet.addons.fontPackReceiver = function(_cg){
            cg = _cg;
            cg.insertReceiver(['font', 'pack'], fontPackReceiver)
        }
        ClassGraph.prototype.generateGoogleLinks = generateGoogleLinks
        ClassGraph.prototype.installGoogleLinks = installGoogleLinks
    }

    /**
     * The handler function given to the dynamic css stylesheet, called
     * when the dcss is prepared.
     *
     * This function activates upon a `font-pack-*` a tree call, converting
     * the leaf object to a font family string.
     * Once generated a new <link> is applied to the HTML head
     *
     * @param  {object} obj  A definition generated by the class graph discovery
     * @return {undefined}
     */
    const fontPackReceiver =  function(obj) {

        // Tokenize as a family string.
        //
        const values = obj.values, origin = obj.origin;
        let fonts = createFontObjects(values, origin, obj)
        let familyStrings = createFamilyString(values, fonts, origin)

        // let families = tokenize(values)

        // install as header <link> items
        // console.info('Installing Google fonts: familyStrings:', familyStrings)
        generateGoogleLinks(familyStrings).forEach((x)=>document.head.appendChild(x))

        // Install additional css additions
        installFontObjects(fonts, obj)
    }

    const installFontObjects = function(fonts, splitObj) {

        // // For value create a font-family;
        for(let pack of Object.values(fonts)) {
            let name = pack.first
            let replaceFunc = ($, ofs) => (ofs ? ' ' : "") //+ $.toLowerCase()
            let cleanName = toTitleCase(name.replace(/[+]/g, replaceFunc))
            // console.log('Installing Font', cleanName)//, pack)
            pack.cleanName = cleanName
            pack.definition = makeDefinitions(pack)
            let installed = cg.dcss.addStylesheetRules(pack.definition);
            installed.renderAll()
        }
    }

    const toTitleCase = function(str) {
        /*convert a string (expected font string) to a title case version
        This also title-cases +prefix string

            foo bar     Foo Bar
            foo+bar     Foo+Bar
        */
        return str.replace(/(^|[\s+])\S/g, function(t) { return t.toUpperCase() });
    }

    // window.toTitleCase = toTitleCase

    const createFamilyString = function(values, fonts, origin) {
        fonts = fonts || createFontObjects(values, origin)
        let fs = function(e) {
            return `family=${e.str}`
        }

        return Object.values(fonts).flatMap((e)=>fs(e)).join('&')
    }

    const makeDefinitions = function(pack) {
        /*
            .roboto-i400 {
                font-family: Roboto;
                font-weight: 300;
                font-style: italic;
            }

        pack:
            cleanName:"Roboto"
            first:"roboto"
            formatStringParts:(2) ['ital', 'wght']
            str:"Roboto:ital,wght@0,100;0,400;0,900;1,300;1,400;1,700;1,900"
            titleToken:"Roboto"
            tokens:
                100:{int: 100, regu: 1}
                300:{int: 300, ital: 1}
                400:{int: 400, regu: 1, ital: 1}
                700:{int: 700, ital: 1}
                900:{int: 900, regu: 1, ital: 1}
         */
        let res = {}
        const asSelector = cg.asSelectorString.bind(cg)
        for(let token of Object.values(pack.tokens)) {
            // console.log('making on token' , token)
            let def = {
                'font-weight': token.int
                , 'font-family': `'${pack.cleanName}', ${pack.defaultFonts}`
            }
            let selectorBits = ['font', pack.first]

            for(let key of token.keys) {
                let newDef = Object.assign({}, def)
                if(key.isItal) {
                    newDef['font-style'] = 'italic'
                }

                let selectorRange = selectorBits.concat([key.token])
                let packName = asSelector(selectorRange)
                let packNameLower = asSelector(selectorRange).toLowerCase()
                // console.log(packName, newDef)
                res[`${packName}, ${packNameLower}`] = newDef
            }

        }

        // Produce a default, withouta size: "font-pack-alta-400-500-600"
        // font-alta-400, ..., font-alta
        let fontOnlyPlusName = asSelector(['font', pack.first])
        let fontOnlyDashName = asSelector(['font'].concat(pack.first.split('+')))
        let strings = new Set([
                        fontOnlyPlusName
                        , fontOnlyDashName
                        , fontOnlyPlusName.toLowerCase()
                        , fontOnlyDashName.toLowerCase()
                        ])

        res[Array.from(strings).join(', ')] = {
                'font-family': `'${pack.cleanName}', ${pack.defaultFonts}`
            }
        return res
    }

    /*
        Given a list of keys, return class-name properties with any
        matching key.

            "font-pack-roboto default-sans-serif"

            getSiblingMutators(['default'], origin)

            default: 'sans-serif
     */
    const getSiblingMutators = function(keys, origin) {
        let results = cg.filterSplit(origin, keys, true)
        // console.log('getSiblingMutators', results)
        return results
    }

    const createFontObjects = function(values, origin, splitObj) {
        // family=Roboto:wght@300
        // let familyStrings = '' //"family=Roboto:wght@300"
        let index = 0
        let fonts = {}
        let _origin = splitObj?.origin || origin;
        let currentFont;
        let regex = /([a-zA-Z-]{0,}?)(\d+)/;
        let REGULAR = 'r' // a no definition (standard) font
        /*
           skip bad tokens
         */
        let skipEmpty = true
        /*
            Enable many fonts to be applied within one class-name
            If false, the string will be classified as a bad tokenised
            string and any _additional_ bad token properties are
            considered Values.
         */
        let manyFont = true
        /*
            If true, allow the appliance of modifiers with an index
            before the primary class.
            If False, the modifier is ignored
         */
        let softIndex = true
        /*
            If true, error out if the modifier index is above the
            primary class index.
            If False, the contribution will continue and potentially
            allow the softmax to continue.
         */
        let errorSoftIndex = false
        // capture the default font from an additional class.
        let sibling = getSiblingMutators(['default'], _origin)
        let defaultFont = 'sans-serif'
        let d = sibling['default']
        if(d) {
            if(d.index <= splitObj.index) {
                // The modifier class is applied before the appliance class.
                // if softIndex = True, allow it.
                // if false, ignore it.
                let func = softIndex? 'warn': 'error'
                let s = 'font default-* modifier should be indexed after font'
                console[func](s)
                if(!softIndex) {
                    // ignore this entry
                    if(errorSoftIndex) {
                        throw new Error(s)
                    }
                } else {
                    // Apply anyway
                    defaultFont = d.values.join(' ')
                }
            } else {
                defaultFont = d.values.join(' ')
            }

        }

        for(let t in values) {

            // A token will be a name or a format type.
            // iterate forward. Test n+1; if n+1 is not a weight, break
            // else continue digesting the weights until a not weight is met.
            // This produces a object dict of { value, font, weights }
            /*
                for token in tokens:
                    if token is not value-like:
                        fonts[token] = current_font = { token, weights:[

                        ] }
                    else:
                        current_font.weights += token

             */
            let token = values[t]

            // if token is weight, stack into the previous (current) font.
            if(index == 0) {
                // the first token should be a font.
                fonts[index] = { first: token, tokens:{}, defaultFonts: defaultFont }
                currentFont = index
                index++;
                continue
            }

            let [prefix, int] = [null, null]
            try{
                // if match int, {v|r|i}int, stack, else continue.
                let _;
                [_, prefix, int] = token.match(regex);
                // console.log(prefix || REGULAR, int)
                if(prefix.length == 0) {
                    prefix = REGULAR
                }
            } catch {
                if(manyFont) {
                    // regenerate the current font and continue forward.
                    // console.log('Building font space', token)
                    fonts[index] = { first: token, tokens:{} }
                    currentFont = index
                    index++;
                    continue
                } else {

                    // bad token
                    if(token.length == 0
                        && skipEmpty == true) {
                        //skip the empties
                        index++;
                        continue
                    }
                    console.warn(`Bad token: "${token}"`)
                }
            }

            let prefixMap = {
                // Here we flag italic or regular.
                // Google fonts accept a formatter "ital,wght" and a value "0,100"
                // italic flag 1: "1,100"
                null: function(){ /* do nothing */ return { regu: 1, wasNull: 1} }
                , 'i': function(){ /* flag italic */  return { ital: 1 } }
                , 'r': function(){ /* flag regular */ return { regu: 1 } }
            }

            let weightDef = {
                int: Number(int)

            }

            if(weightDef.int == 0) {
                // The given weight is likely wrong.
                console.warn('Skipping zero weighted item')
                index++;
                continue
            }

            for(let bit in prefix) {
                let v = prefix[bit]
                let actuator = prefixMap[v]
                Object.assign(weightDef, actuator())
            }

            // console.log('weightDef', weightDef);

            let existing = fonts[currentFont]?.tokens[int] || {};

            Object.assign(existing, weightDef)
            // console.log('Adding to existing keys', token)
            if(existing.keys == undefined) {
                existing.keys = new Set
            }
            existing.keys.add({ isItal: weightDef.ital, token})
            fonts[currentFont].tokens[int] = existing;
            index++;
        }

        return stringifyTokenized(fonts);
    }

    const stringifyTokenized = function(fonts){
        // now make family strings on each type
        for(let i in fonts) {
            let pack = fonts[i]

            if(pack.first.length == 0) {
                //skip blank entries
                continue
            }

            extendPack(pack)
        }


        return fonts
    }

    /*
    Ensure the pack contains one or more tokens.

    This mutates pack.tokens if no tokens are given.
    returns a list of tokenValues, or the _tokens_ of the pack.
     */
    const ensureTokens = function(pack) {

        let tokenValues = Object.values(pack.tokens)

        if(tokenValues.length == 0) {
            pack.tokens["400"] = {
                    int: 400,
                    regu:1,
                    keys: new Set([
                            { isItal: undefined, token: "400"}
                          ])
                } // Install a default font size
        }

        return Object.values(pack.tokens)
    }

    const extendPack = function(pack) {
        let titleToken = toTitleCase(pack.first)
            , tokenValues = ensureTokens(pack)
            , allTokens = Object.assign({}, ...tokenValues)
            , hasItal = allTokens.ital != undefined
            , formatStringParts = []
            , weightValues = new Set
            ;

        if(hasItal) { formatStringParts.push('ital') }
        if(hasItal || allTokens.regu) { formatStringParts.push('wght') }


        for(let key in pack.tokens) {
            let token = pack.tokens[key]
                , ital = token.ital? 1: 0
                , int = token.int
                , a = hasItal? [ital]: []
                ;

            a.push(int)
            let weightStr = a.join(',')
            weightValues.add(weightStr)

            if(token.regu != undefined) {
                let a0 = hasItal? [0]: []
                a0.push(int)
                let regWeightStr = a0.join(',')
                weightValues.add(regWeightStr)

            }
        }

        let weights = Array.from(weightValues).sort()

        let totalWeightStr = weights.join(';')
        let formatString = formatStringParts.join(',')
        let str = `${titleToken}:${formatString}@${totalWeightStr}`

        Object.assign(pack, {
            weights
            , formatStringParts
            , titleToken
            , str
        })
    }

    const generateGoogleLinks = function(familyStrings){

        let a = getOrCreateLink('link', 'preconnect', {
            href: "https://fonts.googleapis.com"
        })

        let b = getOrCreateLink('link', 'preconnect', {
            href: "https://fonts.gstatic.com"
            , crossorigin: ''
        })

        let c = getOrCreateLink('link', "stylesheet", {
            href:`https://fonts.googleapis.com/css2?${familyStrings}&display=swap`
        })

        return [a,b,c]
    }

    let linkCache = {}

    const getOrCreateLink = function(href, rel, opts) {
        let v = {
            rel, href
        }
        Object.assign(v, opts || {})
        let conv = JSON.stringify
        let cached = linkCache[conv(v)]
        if(cached){
            return cached
        }

        return linkCache[conv(v)] = createNode('link', v)
    }

    const createNode = function(name, attrs) {
        if(attrs == undefined && typeof(name) != 'string') {
            attrs = name;
            name = attrs.localName
            if(name == undefined) {
                throw Error('createNode requires a localName within a object definition')
            }
        }

        let node = document.createElement(name)
        for(let key in attrs) {
            node.setAttribute(key, attrs[key])
        }
        return node
    }

    ;insertReceiver();

    return fontPackReceiver

})()
